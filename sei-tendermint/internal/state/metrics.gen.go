// Code generated by metricsgen. DO NOT EDIT.

package state

import (
	"github.com/go-kit/kit/metrics/discard"
	prometheus "github.com/go-kit/kit/metrics/prometheus"
	stdprometheus "github.com/prometheus/client_golang/prometheus"
)

func PrometheusMetrics(namespace string, labelsAndValues ...string) *Metrics {
	labels := []string{}
	for i := 0; i < len(labelsAndValues); i += 2 {
		labels = append(labels, labelsAndValues[i])
	}
	return &Metrics{
		BlockProcessingTime: prometheus.NewHistogramFrom(stdprometheus.HistogramOpts{
			Namespace: namespace,
			Subsystem: MetricsSubsystem,
			Name:      "block_processing_time",
			Help:      "Time between BeginBlock and EndBlock.",

			Buckets: stdprometheus.ExponentialBucketsRange(0.01, 10, 10),
		}, labels).With(labelsAndValues...),
		ConsensusParamUpdates: prometheus.NewCounterFrom(stdprometheus.CounterOpts{
			Namespace: namespace,
			Subsystem: MetricsSubsystem,
			Name:      "consensus_param_updates",
			Help:      "Number of consensus parameter updates returned by the application since process start.",
		}, labels).With(labelsAndValues...),
		ValidatorSetUpdates: prometheus.NewCounterFrom(stdprometheus.CounterOpts{
			Namespace: namespace,
			Subsystem: MetricsSubsystem,
			Name:      "validator_set_updates",
			Help:      "Number of validator set updates returned by the application since process start.",
		}, labels).With(labelsAndValues...),
		FlushAppConnectionTime: prometheus.NewHistogramFrom(stdprometheus.HistogramOpts{
			Namespace: namespace,
			Subsystem: MetricsSubsystem,
			Name:      "flush_app_connection_time",
			Help:      "ValidatorSetUpdates measures how long it takes async ABCI requests to be flushed before committing application state",
		}, labels).With(labelsAndValues...),
		ApplicationCommitTime: prometheus.NewHistogramFrom(stdprometheus.HistogramOpts{
			Namespace: namespace,
			Subsystem: MetricsSubsystem,
			Name:      "application_commit_time",
			Help:      "ApplicationCommitTime meaures how long it takes to commit application state",
		}, labels).With(labelsAndValues...),
		UpdateMempoolTime: prometheus.NewHistogramFrom(stdprometheus.HistogramOpts{
			Namespace: namespace,
			Subsystem: MetricsSubsystem,
			Name:      "update_mempool_time",
			Help:      "UpdateMempoolTime meaures how long it takes to update mempool after commiting, including reCheckTx",
		}, labels).With(labelsAndValues...),
		FinalizeBlockLatency: prometheus.NewHistogramFrom(stdprometheus.HistogramOpts{
			Namespace: namespace,
			Subsystem: MetricsSubsystem,
			Name:      "finalize_block_latency",
			Help:      "FinalizeBlockLatency measures how long it takes to run abci FinalizeBlock",

			Buckets: stdprometheus.ExponentialBucketsRange(0.01, 10, 10),
		}, labels).With(labelsAndValues...),
		SaveBlockResponseLatency: prometheus.NewHistogramFrom(stdprometheus.HistogramOpts{
			Namespace: namespace,
			Subsystem: MetricsSubsystem,
			Name:      "save_block_response_latency",
			Help:      "SaveBlockResponseLatency measures how long it takes to run save the FinalizeBlockRes",

			Buckets: stdprometheus.ExponentialBucketsRange(0.01, 10, 10),
		}, labels).With(labelsAndValues...),
		SaveBlockLatency: prometheus.NewHistogramFrom(stdprometheus.HistogramOpts{
			Namespace: namespace,
			Subsystem: MetricsSubsystem,
			Name:      "save_block_latency",
			Help:      "SaveBlockLatency measure how long it takes to save the block",

			Buckets: stdprometheus.ExponentialBucketsRange(0.01, 10, 10),
		}, labels).With(labelsAndValues...),
		PruneBlockLatency: prometheus.NewHistogramFrom(stdprometheus.HistogramOpts{
			Namespace: namespace,
			Subsystem: MetricsSubsystem,
			Name:      "prune_block_latency",
			Help:      "PruneBlockLatency measures how long it takes to prune block from blockstore",

			Buckets: stdprometheus.ExponentialBucketsRange(0.01, 10, 10),
		}, labels).With(labelsAndValues...),
		FireEventsLatency: prometheus.NewHistogramFrom(stdprometheus.HistogramOpts{
			Namespace: namespace,
			Subsystem: MetricsSubsystem,
			Name:      "fire_events_latency",
			Help:      "FireEventsLatency measures how long it takes to fire events for indexing",

			Buckets: stdprometheus.ExponentialBucketsRange(0.01, 10, 10),
		}, labels).With(labelsAndValues...),
	}
}

func NopMetrics() *Metrics {
	return &Metrics{
		BlockProcessingTime:      discard.NewHistogram(),
		ConsensusParamUpdates:    discard.NewCounter(),
		ValidatorSetUpdates:      discard.NewCounter(),
		FlushAppConnectionTime:   discard.NewHistogram(),
		ApplicationCommitTime:    discard.NewHistogram(),
		UpdateMempoolTime:        discard.NewHistogram(),
		FinalizeBlockLatency:     discard.NewHistogram(),
		SaveBlockResponseLatency: discard.NewHistogram(),
		SaveBlockLatency:         discard.NewHistogram(),
		PruneBlockLatency:        discard.NewHistogram(),
		FireEventsLatency:        discard.NewHistogram(),
	}
}
