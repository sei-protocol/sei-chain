package consensus

import (
	"testing"

	"google.golang.org/protobuf/proto"

	"github.com/sei-protocol/sei-chain/sei-tendermint/internal/autobahn/types"
	"github.com/sei-protocol/sei-chain/sei-tendermint/libs/utils"
)

// genPersistedInner generates a random persistedInner with random optional fields.
func genPersistedInner(rng utils.Rng) *persistedInner {
	p := &persistedInner{}
	if rng.Intn(2) == 1 {
		p.CommitQC = utils.Some(types.GenCommitQC(rng))
	}
	if rng.Intn(2) == 1 {
		p.PrepareQC = utils.Some(types.GenPrepareQC(rng))
	}
	if rng.Intn(2) == 1 {
		p.TimeoutQC = utils.Some(types.GenTimeoutQC(rng))
	}
	if rng.Intn(2) == 1 {
		p.CommitVote = utils.Some(types.GenSigned(rng, types.GenCommitVote(rng)))
	}
	if rng.Intn(2) == 1 {
		p.PrepareVote = utils.Some(types.GenSigned(rng, types.GenPrepareVote(rng)))
	}
	if rng.Intn(2) == 1 {
		p.TimeoutVote = utils.Some(types.GenFullTimeoutVote(rng))
	}
	return p
}

// genFullPersistedInner generates a persistedInner with all fields present.
func genFullPersistedInner(rng utils.Rng) *persistedInner {
	return &persistedInner{
		CommitQC:    utils.Some(types.GenCommitQC(rng)),
		PrepareQC:   utils.Some(types.GenPrepareQC(rng)),
		TimeoutQC:   utils.Some(types.GenTimeoutQC(rng)),
		CommitVote:  utils.Some(types.GenSigned(rng, types.GenCommitVote(rng))),
		PrepareVote: utils.Some(types.GenSigned(rng, types.GenPrepareVote(rng))),
		TimeoutVote: utils.Some(types.GenFullTimeoutVote(rng)),
	}
}

// testProtoRoundtrip tests the protobuf encode→marshal→unmarshal→decode roundtrip.
// Uses google.golang.org/protobuf/proto (not gogo/protobuf) since the pb types
// are generated by protoc-gen-go (google), not protoc-gen-gogo.
func testProtoRoundtrip(t *testing.T, want *persistedInner) {
	t.Helper()
	pb := innerProtoConv.Encode(want)
	raw, err := proto.Marshal(pb)
	if err != nil {
		t.Fatalf("proto.Marshal: %v", err)
	}
	pb.Reset()
	if err := proto.Unmarshal(raw, pb); err != nil {
		t.Fatalf("proto.Unmarshal: %v", err)
	}
	got, err := innerProtoConv.Decode(pb)
	if err != nil {
		t.Fatalf("innerProtoConv.Decode: %v", err)
	}
	if err := utils.TestDiff(want, got); err != nil {
		t.Errorf("roundtrip mismatch: %v", err)
	}
}

// TestPersistedInnerConv tests the protobuf roundtrip for persistedInner.
func TestPersistedInnerConv(t *testing.T) {
	rng := utils.TestRng()
	// Explicitly test boundary cases: empty and fully-populated.
	testProtoRoundtrip(t, &persistedInner{})
	testProtoRoundtrip(t, genFullPersistedInner(rng))
	// Random combinations.
	for range 10 {
		testProtoRoundtrip(t, genPersistedInner(rng))
	}
}
