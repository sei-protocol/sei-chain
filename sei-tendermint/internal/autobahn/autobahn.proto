syntax = "proto3";

package autobahn;

import "hashable/hashable.proto";

option go_package = "github.com/sei-protocol/sei-chain/sei-tendermint/internal/autobahn/pb";

// Timestamp represented as seconds + nanoseconds since UNIX epoch.
// Equivalent of `google.protobuf.Timestamp` but supports canonical encoding.
// See `google.protobuf.Timestamp` for more detailed specification.
message Timestamp {
  option (hashable.hashable) = true;

  // Represents seconds of UTC time since Unix epoch
  // 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
  // 9999-12-31T23:59:59Z inclusive.
  optional int64 seconds = 1; // required

  // Non-negative fractions of a second at nanosecond resolution. Negative
  // second values with fractions must still have non-negative nanos values
  // that count forward in time. Must be from 0 to 999,999,999
  // inclusive.
  optional int32 nanos = 2; // required
}

message Duration {
  option (hashable.hashable) = true;
  optional int64 seconds = 1; // required
  optional int32 nanos = 2; // required
}

message TransactionTimestamps {
  int64 created_at = 1;
  int64 received_at = 2;
}

message TransactionHeader {
  map<string, string> properties = 1;
  string edge_node = 2;
  TransactionTimestamps timestamps = 4;
}

message Transaction {
  string hash = 1;
  bytes payload = 2;
  uint64 gas_used = 3;
  TransactionHeader header = 4;
}

message TransactionResp {
  string hash = 1;
  bool success = 2;
  string message = 3;
}

message PublicKey {
  option (hashable.hashable) = true;
  optional bytes ed25519 = 1; // required
}

message Signature {
  option (hashable.hashable) = true;
  optional PublicKey key = 1; // required
  optional bytes sig = 2; // required
}

message BlockHeader {
  option (hashable.hashable) = true;
  optional PublicKey lane = 1; // required
  optional uint64 block_number = 2; // required
  optional bytes parent_hash = 3; // required
  optional bytes payload_hash = 4; // required
}

message Payload {
  option (hashable.hashable) = true;
  optional Timestamp created_at = 1; // required
  optional uint64 total_gas = 2; // required
  optional int64 edge_count = 3; // required
  optional bytes coinbase = 4; // required
  optional int64 basefee = 5; // required
  repeated bytes txs = 6;
}

message Block {
  option (hashable.hashable) = true;
  optional BlockHeader header = 1; // required
  optional Payload payload = 2; // required
}

message LaneQC {
  BlockHeader vote = 1;
  repeated Signature sigs = 2;
}

message LaneRange {
  option (hashable.hashable) = true;
  optional PublicKey lane = 1; // required
  optional uint64 first = 2; // required
  optional uint64 next = 3; // required
  optional bytes last_hash = 4; // required
}

message View {
  option (hashable.hashable) = true;
  optional uint64 index = 1; // required
  optional uint64 number = 2; // required
}

message Proposal {
  option (hashable.hashable) = true;
  optional View view = 1; // required.
  optional Timestamp created_at = 2; // required
  repeated LaneRange lane_ranges = 3; // Sorted by lane.
  optional AppProposal app = 4; // optional
}

message FullProposal {
  SignedMsg proposal = 1;
  repeated LaneQC lane_qcs = 2;
  optional AppQC app_qc = 3;
  optional TimeoutQC timeout_qc = 4; // justifies the proposal.
}

message PrepareQC {
  Proposal vote = 1;
  repeated Signature sigs = 2;
}

message CommitQC {
  Proposal vote = 1;
  repeated Signature sigs = 3;
}

message FullCommitQC {
  CommitQC qc = 1;
  repeated BlockHeader headers = 2;
}

message TimeoutVote {
  option (hashable.hashable) = true;
  optional View view = 1; // required
  optional uint64 latest_prepare_qc_view_number = 2; // optional
}

message TimeoutQC {
  repeated SignedMsg votes = 1;
  optional PrepareQC latest_prepare_qc = 2;
}

message FullTimeoutVote {
  SignedMsg vote = 1;
  optional PrepareQC latest_prepare_qc = 2;
}

// Persisted consensus state (for crash recovery).
// Only persist votes and QCs here - these are the canonical consensus artifacts.
// Do NOT persist internal derived fields (e.g., cached computations, runtime state).
// Derived fields are implementation-dependent and should be recomputed on load.
message PersistedInner {
  optional CommitQC commit_qc = 1;
  optional PrepareQC prepare_qc = 2;
  optional TimeoutQC timeout_qc = 3;

  optional SignedMsg commit_vote = 4;
  optional SignedMsg prepare_vote = 5;
  optional FullTimeoutVote timeout_vote = 6;
}

// Wrapper for persisted data with sequence number.
message PersistedWrapper {
  optional uint64 seq = 1;
  optional bytes data = 2;
}

message AppQC {
  AppProposal vote = 1;
  repeated Signature sigs = 2;
}

message AppProposal {
  option (hashable.hashable) = true;
  // Global block number.
  optional uint64 global_number = 1; // required
  // Index of the commit qc finalizing the block.
  optional uint64 road_index = 2; // required
  // App hash at that block.
  optional bytes app_hash = 3; // required
}

// This is the signable message.
// To sign ConsensusMsg/BlockMsg, you need to embed it in Msg first.
message Msg {
  option (hashable.hashable) = true;
  oneof t { // required
    // Lane
    Block lane_proposal = 1;
    BlockHeader lane_vote = 2;

    // Consensus
    Proposal proposal = 3;
    Proposal prepare_vote = 4;
    Proposal commit_vote = 5;
    TimeoutVote timeout_vote = 6;

    // App
    AppProposal app_vote = 7;
  }
}

message SignedMsg {
  Msg msg = 1;
  Signature sig = 2;
}

// TODO(gprusak): rename to ConsensusMsg
message ConsensusReq {
  oneof t {
    FullProposal proposal = 1;
    SignedMsg prepare_vote = 2;
    SignedMsg commit_vote = 3;
    FullTimeoutVote timeout_vote = 4;
    TimeoutQC timeout_qc = 5;
  }
}
