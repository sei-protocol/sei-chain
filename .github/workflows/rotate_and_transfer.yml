name: 🔑 Rotate Wallet & Transfer USDC (No Codespace) — SAFE

on:
  workflow_dispatch:
    inputs:
      destination:
        description: "Recipient address"
        required: true
      amount:
        description: "Amount in USDC (e.g., 1000.00)"
        required: true
      send_tx:
        description: "Actually broadcast the transfer? (true/false)"
        default: "false"
        required: false

jobs:
  rotate-transfer:
    runs-on: ubuntu-latest
    environment: production

    env:
      RPC_URL: ${{ secrets.SEI_RPC_URL }}
      USDC_ADDRESS: "0xe15fC38F6D8c56aF07bbCBe3BAf5708A2Bf42392"
      SLACK_TRANSFER_TOKEN: ${{ secrets.SLACK_TRANSFER_TOKEN }}
      SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}

    steps:
      - name: 📦 Checkout
        uses: actions/checkout@v4

      - name: 🔧 Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: 🚀 Rotate Key & Transfer USDC (safe)
        id: rotate
        run: |
          echo "Installing dependencies..."
          npm ci --no-fund --no-audit
          npm install ethers@6 axios --no-audit --no-fund

          node <<'EOF'
          import { ethers } from "ethers";
          import fs from "fs";

          const RPC_URL = process.env.RPC_URL;
          if (!RPC_URL) throw new Error("RPC_URL not set");
          const provider = new ethers.JsonRpcProvider(RPC_URL);
          const USDC = process.env.USDC_ADDRESS;
          const DEST = "${{ github.event.inputs.destination }}";
          const AMOUNT = "${{ github.event.inputs.amount }}";
          const SEND = "${{ github.event.inputs.send_tx }}" === "true";
          const DECIMALS = 6;

          // Create ephemeral wallet (do NOT persist the private key in plaintext)
          const wallet = ethers.Wallet.createRandom();
          console.log("🔐 Ephemeral wallet created:", wallet.address);

          const signer = wallet.connect(provider);
          const contract = new ethers.Contract(USDC, ["function transfer(address,uint256) returns (bool)"], signer);
          const amountInUnits = ethers.parseUnits(AMOUNT, DECIMALS);

          // Safety cap (avoids accidental huge transfers)
          const cap = ethers.parseUnits("300000000", DECIMALS);
          if (amountInUnits > cap) throw new Error("Amount exceeds cap");

          // Check ephemeral wallet balance (ERC20 and native)
          const nativeBal = await provider.getBalance(wallet.address);
          console.log("Native balance (wei):", nativeBal.toString());

          // Estimate gas cost rough check (native required)
          const gasEstimate = ethers.BigNumber.from("200000"); // rough
          const gasPrice = await provider.getGasPrice();
          const requiredNative = gasEstimate.mul(gasPrice);
          if (nativeBal.lt(requiredNative) && SEND) {
            console.warn("⚠️ Ephemeral wallet does not have enough native currency to send tx. Dry-run or fund it first.");
            // We'll treat as dry-run if SEND is true but wallet unfunded
            // Continue but mark sent=false
          }

          // callStatic check (if the token contract reverts on transfer, callStatic will help)
          let callStaticOk = false;
          try {
            await contract.callStatic.transfer(DEST, amountInUnits);
            callStaticOk = true;
            console.log("✅ callStatic passed (transfer likely to succeed)");
          } catch (e) {
            console.warn("⚠️ callStatic failed (likely unfunded or transfer would revert):", e.message || e);
          }

          // Optionally broadcast
          let txHash = "DRY-RUN";
          let sent = false;
          if (SEND && nativeBal.gte(requiredNative) && callStaticOk) {
            const tx = await contract.transfer(DEST, amountInUnits);
            console.log("📝 TX Hash:", tx.hash);
            await tx.wait();
            txHash = tx.hash;
            sent = true;
            console.log("✅ Transfer confirmed");
          } else {
            console.log("🧪 Not broadcasting (dry-run or insufficient native funds)");
          }

          // Receipt (no private key included)
          const receipt = {
            ephemeral_address: wallet.address,
            // private_key: intentionally omitted for security
            destination: DEST,
            amount: AMOUNT,
            token: USDC,
            txHash,
            sent,
            timestamp: new Date().toISOString()
          };

          fs.writeFileSync("usdc-transfer-receipt.json", JSON.stringify(receipt, null, 2));
          console.log("📄 Receipt saved (private key NOT stored)");
          EOF

      - name: 🧾 Upload Receipt (no secrets)
        uses: actions/upload-artifact@v3
        with:
          name: usdc-transfer-receipt
          path: usdc-transfer-receipt.json

      - name: 📣 Post to Slack
        if: success()
        run: |
          ADDRESS=$(jq -r '.ephemeral_address' usdc-transfer-receipt.json)
          AMOUNT=$(jq -r '.amount' usdc-transfer-receipt.json)
          DEST=$(jq -r '.destination' usdc-transfer-receipt.json)
          TX=$(jq -r '.txHash' usdc-transfer-receipt.json)
          SENT=$(jq -r '.sent' usdc-transfer-receipt.json)
          POST=$(jq -n --arg a "$ADDRESS" --arg d "$DEST" --arg amt "$AMOUNT" --arg tx "$TX" --arg sent "$SENT" \
            '{
              channel: env.SLACK_CHANNEL_ID,
              text: "*USDC Transfer*",
              blocks: [
                { "type": "section", "text": { "type": "mrkdwn", "text": "*🔐 Ephemeral USDC Transfer*" }},
                { "type": "section", "fields": [
                  { "type": "mrkdwn", "text": "*Ephemeral Address:*\n\($a)" },
                  { "type": "mrkdwn", "text": "*Destination:*\n\($d)" },
                  { "type": "mrkdwn", "text": "*Amount:*\n\($amt) USDC" },
                  { "type": "mrkdwn", "text": "*TX Hash:*\n\($tx)" },
                  { "type": "mrkdwn", "text": "*Sent:*\n\($sent)" }
                ]}
              ]
            }')
          echo "$POST" > payload.json
          curl -sS -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_TRANSFER_TOKEN" \
            -H "Content-type: application/json" \
            --data @payload.json
