name: PR → Codex review → Slack

on:
  pull_request:
    types: [opened, reopened, ready_for_review]

jobs:
  codex_review:
    # Run only for trusted contributors
    if: ${{ contains(fromJSON('["OWNER","MEMBER","COLLABORATOR","CONTRIBUTOR"]'), github.event.pull_request.author_association) }}

    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      pull-requests: write

    env:
      # Toggle this to "1" to force posting even for diagnostics (normally "0")
      FORCE_SLACK_POST: "0"

    steps:
      - name: Checkout PR HEAD (full history)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Codex CLI
        run: npm i -g @openai/codex

      - name: Print environment diagnostics (safe)
        run: |
          set -euo pipefail
          echo "Node: $(node -v)"
          echo "NPM:  $(npm -v)"
          echo "Codex CLI version:"
          codex --version || echo "codex --version failed (CLI not on PATH?)"
          echo
          echo "Author association: ${{ github.event.pull_request.author_association }}"
          echo "Repo: ${{ github.repository }}"
          echo "PR:   #${{ github.event.pull_request.number }}"

      - name: Compute merge-base diff (compact)
        run: |
          set -euo pipefail
          BASE_REF='${{ github.event.pull_request.base.ref }}'
          git fetch --no-tags origin "$BASE_REF":"refs/remotes/origin/$BASE_REF"
          MB=$(git merge-base "origin/$BASE_REF" HEAD)
          git diff --unified=0 "$MB"..HEAD > pr.diff
          git --no-pager diff --stat "$MB"..HEAD > pr.stat || true
          BYTES=$(wc -c < pr.diff || echo 0)
          echo "pr.diff size: $BYTES bytes"

      - name: Build prompt and run Codex (guard + verbose logging)
        id: codex
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          # Pass the API key into the step environment for presence checking.
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          set -x
          MAX=${MAX_DIFF_BYTES:-900000} # ~0.9MB ceiling
          BYTES=$(wc -c < pr.diff || echo 0)

          # Prepare a human-readable review file from the start
          : > review.md

          # 1) Hard fail early if the secret isn't present (typical for forks on pull_request)
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            {
              echo "## Executive summary"
              echo "This run came from a context where repository secrets are unavailable (e.g., a fork PR on pull_request)."
              echo
              echo "## Findings and fixes"
              echo "- **Diagnostic**: Missing \`OPENAI_API_KEY\` in CI environment, so the Codex CLI cannot authenticate."
              echo "- **What to do**: Re-run on an internal branch PR or use a maintainer-triggered workflow that has access to secrets."
            } > review.md
            echo "diagnostic_reason=missing_openai_api_key" >> "$GITHUB_OUTPUT"
            echo "codex_exit=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # 2) Build prompt
          {
            echo "You are a skilled AppSec reviewer. Analyze this PR for:"
            echo "bugs, vulnerabilities, loss of funds issues, crypto attack vectors, signature vulnerability, replay attacks etc.."
            echo "Think deeply. Prioritize the *changed hunks* in pr.diff, but open any other files"
            echo "in the checkout as needed for context."
            echo
            echo "Return a tight executive summary, then bullets with:"
            echo "- severity (high/med/low)"
            echo "- file:line pointers"
            echo "- concrete fixes & example patches"
            echo '- if N/A, say "No significant issues found."'
            echo
            echo "PR URL: $PR_URL"
            echo
            echo "Formatting requirements:"
            echo "- Output MUST be GitHub-flavored Markdown (GFM)."
            echo "- Start with '## Executive summary' (one short paragraph)."
            echo "- Then '## Findings and fixes' as a bullet list."
            echo "- Use fenced code blocks for patches/configs with language tags (diff, yaml, etc.)."
            echo "- Use inline code for file:line and identifiers."
          } > prompt.txt

          if [ "$BYTES" -le "$MAX" ] && [ "$BYTES" -gt 0 ]; then
            {
              echo
              echo "Unified diff (merge-base vs HEAD):"
              echo '```diff'
              cat pr.diff
              echo '```'
            } >> prompt.txt
            echo "---- prompt head ----"
            head -n 40 prompt.txt
            echo "---- prompt size ----"
            wc -c prompt.txt

            # Run Codex with a scrubbed env, but include necessary vars explicitly
            # Capture both stdout/stderr to codex.log and mirror to console
            set +e
            env -i OPENAI_API_KEY="${OPENAI_API_KEY}" PATH="$PATH" HOME="$HOME" \
              codex --model gpt-5-codex --ask-for-approval never exec \
                --sandbox read-only \
                --output-last-message review.md \
                < prompt.txt \
                > >(tee codex.log) 2>&1
            EXIT_CODE=$?
            set -e
          else
            # Fallback: diff too large; let Codex fetch the URL
            BASE_REF='${{ github.event.pull_request.base.ref }}'
            git fetch --no-tags origin "$BASE_REF":"refs/remotes/origin/$BASE_REF"
            MB=$(git merge-base "origin/$BASE_REF" HEAD)
            HEAD_SHA=$(git rev-parse HEAD)
            DIFF_URL="${PR_URL}.diff"
            {
              echo
              echo "The diff is too large to embed safely in this CI run."
              echo "Please fetch and analyze the diff from this URL:"
              echo "$DIFF_URL"
              echo
              echo "Commit range (merge-base...HEAD):"
              echo "merge-base: $MB"
              echo "head:       $HEAD_SHA"
              echo
              echo "For quick orientation, here is the diffstat:"
              echo '```'
              cat pr.stat || true
              echo '```'
            } >> prompt.txt
            echo "---- fallback prompt head ----"
            head -n 80 prompt.txt
            echo "---- fallback prompt size ----"
            wc -c prompt.txt

            set +e
            env -i OPENAI_API_KEY="${OPENAI_API_KEY}" PATH="$PATH" HOME="$HOME" \
              codex --ask-for-approval never exec \
                --sandbox danger-full-access \
                --output-last-message review.md \
                < prompt.txt \
                > >(tee codex.log) 2>&1
            EXIT_CODE=$?
            set -e
          fi

          echo "---- codex exit code ----"
          echo "$EXIT_CODE"
          echo "---- codex.log (last 200 lines) ----"
          tail -n 200 codex.log || true

          # If the CLI failed, explain why in the review file for easy visibility
          if [ "$EXIT_CODE" -ne 0 ]; then
            {
              echo
              echo "## Codex CLI error details"
              echo ""
              echo "Exit code: $EXIT_CODE"
              echo ""
              echo "### codex.log (tail)"
              echo '```text'
              tail -n 200 codex.log || true
              echo '```'
            } >> review.md
          fi

          # Defensive: ensure later steps don't explode, but keep real diagnostics
          if [ ! -s review.md ]; then
            echo "_Codex produced no output._" > review.md
          fi

          # Export some signals for downstream steps
          REVIEW_BYTES=$( (stat -c%s review.md 2>/dev/null || stat -f%z review.md 2>/dev/null) || echo 0 )
          echo "review_bytes=$REVIEW_BYTES" >> "$GITHUB_OUTPUT"
          echo "codex_exit=$EXIT_CODE" >> "$GITHUB_OUTPUT"

          # If we only have the placeholder or a diagnostic, we will skip Slack
          if grep -q "^_Codex produced no output._$" review.md; then
            echo "post_slack=0" >> "$GITHUB_OUTPUT"
          elif grep -qi "^## Executive summary" review.md && [ "${FORCE_SLACK_POST}" != "1" ] && grep -qi "Diagnostic" review.md; then
            echo "post_slack=0" >> "$GITHUB_OUTPUT"
          else
            echo "post_slack=1" >> "$GITHUB_OUTPUT"
          fi

      - name: Post parent message in Slack (blocks)
        id: post_parent
        if: ${{ steps.codex.outputs.post_slack == '1' }}
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
        run: |
          resp=$(curl -s -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H 'Content-type: application/json; charset=utf-8' \
            --data "$(jq -n \
              --arg ch "$SLACK_CHANNEL_ID" \
              --arg n  "${{ github.event.pull_request.number }}" \
              --arg t  "${{ github.event.pull_request.title }}" \
              --arg a  "${{ github.event.pull_request.user.login }}" \
              --arg u  "${{ github.event.pull_request.html_url }}" \
              '{
                channel: $ch,
                text: ("PR #" + $n + ": " + $t),
                blocks: [
                  { "type":"section", "text":{"type":"mrkdwn","text":("*PR #"+$n+":* "+$t)} },
                  { "type":"section", "text":{"type":"mrkdwn","text":("• Author: "+$a)} },
                  { "type":"section", "text":{"type":"mrkdwn","text":("• Link: <"+$u+">")} }
                ],
                unfurl_links:false, unfurl_media:false
              }')" )
          echo "ts=$(echo "$resp" | jq -r '.ts')" >> "$GITHUB_OUTPUT"

      - name: Thread reply with review (upload via Slack external upload API)
        if: ${{ steps.codex.outputs.post_slack == '1' }}
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
          TS: ${{ steps.post_parent.outputs.ts }}
        run: |
          set -euo pipefail
          BYTES=$( (stat -c%s review.md 2>/dev/null || stat -f%z review.md 2>/dev/null) )
          BYTES=${BYTES:-$(wc -c < review.md | tr -d '[:space:]')}
          ticket=$(curl -sS -X POST https://slack.com/api/files.getUploadURLExternal \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-type: application/x-www-form-urlencoded" \
            --data-urlencode "filename=codex_review.md" \
            --data "length=$BYTES" \
            --data "snippet_type=markdown")
          echo "$ticket"
          upload_url=$(echo "$ticket" | jq -r '.upload_url')
          file_id=$(echo "$ticket" | jq -r '.file_id')
          test "$upload_url" != "null" -a "$file_id" != "null" || { echo "getUploadURLExternal failed: $ticket" >&2; exit 1; }
          curl -sS -X POST "$upload_url" \
            -F "filename=@review.md;type=text/markdown" \
            > /dev/null
          payload=$(jq -n --arg fid "$file_id" --arg ch "$SLACK_CHANNEL_ID" --arg ts "$TS" \
            --arg title "Codex Security Review" --arg ic "Automated Codex review attached." \
            '{files:[{id:$fid, title:$title}], channel_id:$ch, thread_ts:$ts, initial_comment:$ic}')
          resp=$(curl -sS -X POST https://slack.com/api/files.completeUploadExternal \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-type: application/json; charset=utf-8" \
            --data "$payload")
          echo "$resp"
          test "$(echo "$resp" | jq -r '.ok')" = "true" || { echo "files.completeUploadExternal failed: $resp" >&2; exit 1; }
