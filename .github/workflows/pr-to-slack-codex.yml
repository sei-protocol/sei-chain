name: PR → Codex review → Slack

on:
  pull_request:
    types: [opened, reopened, ready_for_review, synchronize]

jobs:
  codex_review:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      pull-requests: write
    env:
      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
      SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

    steps:
      - name: Checkout PR HEAD (full history)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Codex CLI
        run: npm i -g @openai/codex

      - name: Compute merge-base diff (compact)
        run: |
          set -euo pipefail
          BASE_REF='${{ github.event.pull_request.base.ref }}'
          git fetch --no-tags origin "$BASE_REF":"refs/remotes/origin/$BASE_REF"
          MB=$(git merge-base "origin/$BASE_REF" HEAD)
          git diff --unified=0 "$MB"..HEAD > pr.diff
          git --no-pager diff --stat "$MB"..HEAD > pr.stat || true

      - name: Build prompt and run Codex (guard + fallback)
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail
          MAX=${MAX_DIFF_BYTES:-900000} # ~0.9MB ceiling; override via env if needed

          BYTES=$(wc -c < pr.diff || echo 0)
          echo "pr.diff size: $BYTES bytes (limit: $MAX)"

          # Common prelude for AppSec review
          {
            echo "You are a skilled AppSec reviewer. Analyze this PR for:"
            echo "bugs, vulnerabilities, loss of funds issues, crypto attack vectors, etc."
            echo "Prioritize the *changed hunks* in pr.diff, but open any other files"
            echo "in the checkout as needed for context."
            echo
            echo "Return a tight executive summary, then bullets with:"
            echo "- severity (high/med/low)"
            echo "- file:line pointers"
            echo "- concrete fixes & example patches"
            echo '- if N/A, say "No significant issues found."'
            echo
            echo "PR URL: $PR_URL"
            echo
          } > prompt.txt

          if [ "$BYTES" -le "$MAX" ] && [ "$BYTES" -gt 0 ]; then
            echo "Using embedded diff path (<= $MAX bytes)"
            {
              echo "Unified diff (merge-base vs HEAD):"
              echo '```diff'
              cat pr.diff
              echo '```'
            } >> prompt.txt

            echo "---- prompt head ----"; head -n 40 prompt.txt >&2
            echo "---- prompt size ----"; wc -c prompt.txt >&2

            codex --ask-for-approval never exec \
              --sandbox read-only \
              --output-last-message review.md \
              < prompt.txt \
              > codex.log 2>&1

          else
            echo "Large diff – switching to fallback that lets Codex fetch the .diff URL"
            # Recompute merge-base and HEAD for clarity in the prompt
            BASE_REF='${{ github.event.pull_request.base.ref }}'
            git fetch --no-tags origin "$BASE_REF":"refs/remotes/origin/$BASE_REF"
            MB=$(git merge-base "origin/$BASE_REF" HEAD)
            HEAD_SHA=$(git rev-parse HEAD)
            DIFF_URL="${PR_URL}.diff"

            {
              echo "The diff is too large to embed safely in this CI run."
              echo "Please fetch and analyze the diff from this URL:"
              echo "$DIFF_URL"
              echo
              echo "Commit range (merge-base...HEAD):"
              echo "merge-base: $MB"
              echo "head:       $HEAD_SHA"
              echo
              echo "For quick orientation, here is the diffstat:"
              echo '```'
              cat pr.stat || true
              echo '```'
              echo
              echo "After fetching the diff, continue with the same review instructions above."
            } >> prompt.txt

            echo "---- fallback prompt head ----"; head -n 80 prompt.txt >&2
            echo "---- fallback prompt size ----"; wc -c prompt.txt >&2

            # Network-enabled only for this large-diff case
            codex --ask-for-approval never exec \
              --sandbox danger-full-access \
              --output-last-message review.md \
              < prompt.txt \
              > codex.log 2>&1
          fi

          # Defensive: ensure later steps don't explode
          if [ ! -s review.md ]; then
            echo "_Codex produced no output._" > review.md
          fi

      - name: Post parent message in Slack (blocks)
        id: post_parent
        run: |
          resp=$(curl -s -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H 'Content-type: application/json; charset=utf-8' \
            --data "$(jq -n \
              --arg ch "$SLACK_CHANNEL_ID" \
              --arg n  "${{ github.event.pull_request.number }}" \
              --arg t  "${{ github.event.pull_request.title }}" \
              --arg a  "${{ github.event.pull_request.user.login }}" \
              --arg u  "${{ github.event.pull_request.html_url }}" \
              '{
                channel: $ch,
                text: ("PR #" + $n + ": " + $t),
                blocks: [
                  { "type":"section", "text":{"type":"mrkdwn","text":("*PR #"+$n+":* "+$t)} },
                  { "type":"section", "text":{"type":"mrkdwn","text":("• Author: "+$a)} },
                  { "type":"section", "text":{"type":"mrkdwn","text":("• Link: <"+$u+">")} }
                ],
                unfurl_links:false, unfurl_media:false
              }')" )
          echo "ts=$(echo "$resp" | jq -r '.ts')" >> "$GITHUB_OUTPUT"

      - name: Thread reply with review (auto file upload if large)
        env:
          TS: ${{ steps.post_parent.outputs.ts }}
        run: |
          set -euo pipefail
          BYTES=$(wc -c < review.md || echo 0)
          if [ "$BYTES" -gt 35000 ]; then
            # Safer path for big outputs: upload as a file in the thread
            curl -s -F "channels=$SLACK_CHANNEL_ID" \
                   -F "thread_ts=$TS" \
                   -F "filename=codex_review.md" \
                   -F "title=Codex Security Review" \
                   -F "initial_comment=Automated Codex review attached." \
                   -F "file=@review.md" \
                   -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                   https://slack.com/api/files.upload >/dev/null
          else
            body=$(jq -Rs . < review.md)
            curl -s -X POST https://slack.com/api/chat.postMessage \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              -H 'Content-type: application/json; charset=utf-8' \
              --data "{\"channel\":\"$SLACK_CHANNEL_ID\",\"thread_ts\":\"$TS\",\"text\":$body,\"unfurl_links\":false,\"unfurl_media\":false}" \
              >/dev/null
          fi
