name: Life-NDA-License-Full-Pipeline

on:
  workflow_dispatch:
    inputs:
      accept_trigger:
        description: "Trigger license grant and artifact broadcast via SeiContrib"
        required: true
        default: "no"
  push:
    branches:
      - main
      - release/**

concurrency:
  cancel-in-progress: true
  group: ${{ github.workflow }}-${{ github.event_name }}-${{ github.sha || github.ref }}

jobs:
  manifest:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      id-token: write
    steps:
      - uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python dependencies
        run: pip install web3 eth_account cryptography requests

      - name: Generate NDA + License Manifest
        run: |
          mkdir -p manifest/out
          python3 << 'EOF'
import os, json, time
from cryptography.fernet import Fernet

manifest = {
  "version": "LifeBase-License-v1",
  "timestamp_unix": int(time.time()),
  "purpose": "NDA-Protected IP with conditional license grant",
  "sovereign_rights": {
      "life_support": True,  # yours only
      "creator_intent": "Information bound here cannot be used to train, inform, enrich, or enable any 3rd party or commercial system."
  },
  "nda_terms": {
      "non_disclosure": True,
      "non_transfer": True,
      "no_corporate_use": True,
      "no_trade_secret_absorption": True,
      "allowed_use": "Execution of this manifest only."
  },
  "license": {
      "granted": os.getenv("LICENSE_TRIGGER")=="yes",
      "scope": "All IP and modules outside life_support",
      "conditions": "License only effective after initial payment received."
  }
}

# Encrypt NDA-sensitive fields
key = os.getenv("MANIFEST_KEY").encode()
fernet = Fernet(key)
for field in ["nda_terms"]:
    manifest[field+"_encrypted"] = fernet.encrypt(json.dumps(manifest[field]).encode()).decode()

with open("manifest/out/license_manifest.json","w") as f:
    json.dump(manifest,f,indent=2)
EOF

      - name: Sign Manifest
        env:
          PRIV: ${{ secrets.PRIVATE_KEY }}
        run: |
          python3 << 'EOF'
import json, os
from eth_account import Account
from web3 import Web3

w3 = Web3()
with open("manifest/out/license_manifest.json") as f:
    payload = json.load(f)

acct = Account.from_key(os.getenv("PRIV"))
message = json.dumps(payload, separators=(",", ":"), sort_keys=True)
signed = acct.sign_message(w3.eth.account.signable_message(message))

out = {"manifest": payload, "signature": signed.signature.hex(), "signer": acct.address}
with open("manifest/out/signed_license_manifest.json", "w") as f:
    json.dump(out,f,indent=2)
EOF

      - name: Set up Node.js for Web3 Fallback/Health
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Node dependencies
        run: npm install web3 abort-controller node-fetch

      - name: Run Web3 RPC Health + Select Best RPC
        id: select_rpc
        run: |
          mkdir -p web3
          cat << 'JS' > web3/index.js
const Web3 = require('web3');
const fetch = require('node-fetch');
const AbortController = require('abort-controller');

async function checkRpcHealth(rpcUrls, timeoutMs = 3000) {
  const results = [];
  for(const url of rpcUrls){
    const controller = new AbortController();
    const start = Date.now();
    const timeout = setTimeout(()=>controller.abort(), timeoutMs);
    try {
      const res = await fetch(url, {method:'POST',body:JSON.stringify({jsonrpc:'2.0',method:'eth_blockNumber',params:[],id:1}),headers:{'Content-Type':'application/json'},signal:controller.signal});
      const end = Date.now();
      results.push({url,status:res.ok?'✅ Healthy':`❌ HTTP ${res.status}`,responseTime:end-start});
    } catch(e){
      results.push({url,status:`❌ ${e.name}`,responseTime:null});
    } finally { clearTimeout(timeout); }
  }
  results.sort((a,b)=>a.responseTime-(b.responseTime||Infinity));
  return results;
}

module.exports = { checkRpcHealth };
JS

          cat << 'JS' > web3/run.js
const { checkRpcHealth } = require('./index');
const rpcUrls = ['https://rpc1.example.com','https://evm.confluxrpc.com','https://rpc.flashbots.net'];
(async()=>{
  const health = await checkRpcHealth(rpcUrls);
  console.table(health.map(s=>({RPC:s.url,Status:s.status,'Response Time (ms)':s.responseTime||'—'})));
  const best = health.find(r=>r.status.includes('✅'));
  console.log('::set-output name=best_rpc::'+(best?best.url:''));
})();
JS

          node web3/run.js

      - name: Broadcast License Manifest via Best RPC if Triggered
        if: ${{ github.event.inputs.accept_trigger == 'yes' }}
        env:
          RPC: ${{ steps.select_rpc.outputs.best_rpc }}
        run: |
          python3 << 'EOF'
import os, json, requests
with open("manifest/out/signed_license_manifest.json") as f:
    signed = json.load(f)
rpc = os.getenv("RPC")
tx = {"jsonrpc":"2.0","method":"eth_sendRawTransaction","params":[signed["signature"]],"id":1}
resp = requests.post(rpc,json=tx)
print(resp.text)
EOF

      - name: Upload Protected Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: life-nda-license
          path: manifest/out

  go-tests:
    runs-on: ubuntu-latest
    needs: manifest
    strategy:
      fail-fast: false
      matrix:
        modules:
          - name: sei-chain
            path: ./
          - name: sei-cosmos
            path: ./sei-cosmos
            tags: ledger test_ledger_mock
          - name: sei-db
            path: ./sei-db
          - name: sei-tendermint
            path: ./sei-tendermint
          - name: sei-wasmd
            path: ./sei-wasmd
            tags: ledger test_ledger_mock
          - name: sei-wasmvm
            path: ./sei-wasmvm
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-go@v6
        with: go-version: '1.24'
      - name: Remove unnecessary tooling
        run: |
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force
      - name: Go test with race detector
        working-directory: ${{ matrix.modules.path }}
        run: |
          if [ -z "${{ matrix.modules.tags }}" ]; then
            go test -race -timeout=30m -covermode=atomic -coverprofile=coverage.out ./...
          else
            go test -race -tags='${{ matrix.modules.tags }}' -timeout=30m -covermode=atomic -coverprofile=coverage.out ./...
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          fail_ci_if_error: true
          disable_search: true
          name: ${{ matrix.modules.name }}-coverage
          files: ${{ matrix.modules.path }}/coverage.out
          flags: ${{ matrix.modules.name }}
