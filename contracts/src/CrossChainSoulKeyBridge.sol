// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";

/// @notice Minimal interface for Circle's message transmitter used by CCIP.
interface IMessageTransmitter {
    function receiveMessage(bytes calldata message, bytes calldata attestation) external returns (bool);
}

/// @notice Simplified interface representing the Wormhole relayer entry point used for Solana proofs.
interface IWormholeRelayer {
    function forwardProof(bytes calldata payload) external;
}

/// @title CrossChainSoulKeyBridge
/// @notice Coordinates the delivery of zkSoulProof attestations from Sei, Polygon and Solana into EVM vault gates.
/// @dev The contract focuses on orchestrating calls into existing verifiers/routers rather than validating proofs itself.
contract CrossChainSoulKeyBridge is Ownable {
    /// @notice CCIP message transmitter used for Sei and Polygon proof forwarding.
    address public immutable messageTransmitter;

    /// @notice Wormhole relayer contract that is authorised to push Solana proofs on chain.
    address public immutable wormholeRelayer;

    /// @notice SoulKey access gate on the destination EVM chain that performs final verification.
    address public soulKeyGate;

    event SoulKeyGateUpdated(address indexed previousGate, address indexed newGate);
    event SeiProofForwarded(address indexed sender, bytes32 indexed proofHash, bytes attestation);
    event PolygonProofForwarded(address indexed sender, bytes32 indexed proofHash, bytes attestation);
    event SolanaProofReceived(bytes32 indexed proofHash);

    error InvalidAddress(string parameter);
    error WormholeRelayerOnly();
    error SoulKeyVerificationFailed();

    constructor(address transmitter, address relayer, address initialSoulKeyGate) Ownable(msg.sender) {
        if (transmitter == address(0)) {
            revert InvalidAddress("transmitter");
        }
        if (relayer == address(0)) {
            revert InvalidAddress("relayer");
        }
        if (initialSoulKeyGate == address(0)) {
            revert InvalidAddress("soulKeyGate");
        }
        messageTransmitter = transmitter;
        wormholeRelayer = relayer;
        soulKeyGate = initialSoulKeyGate;
    }

    /// @notice Updates the destination soul key gate.
    /// @dev Owner callable to support upgrades of the verification contract.
    function setSoulKeyGate(address newSoulKeyGate) external onlyOwner {
        if (newSoulKeyGate == address(0)) {
            revert InvalidAddress("soulKeyGate");
        }
        address previous = soulKeyGate;
        soulKeyGate = newSoulKeyGate;
        emit SoulKeyGateUpdated(previous, newSoulKeyGate);
    }

    /// @notice Forwards a Sei originated proof into the CCIP transmitter for verification on EVM.
    /// @param message Encoded payload generated by the Sei contract (recipient address, proof, metadata).
    /// @param attestation CCIP attestation accompanying the payload.
    function forwardSeiProof(bytes calldata message, bytes calldata attestation) external {
        bytes32 proofHash = keccak256(message);
        IMessageTransmitter(messageTransmitter).receiveMessage(message, attestation);
        emit SeiProofForwarded(msg.sender, proofHash, attestation);
    }

    /// @notice Forwards a Polygon origin proof into CCIP.
    /// @param message ABI encoded payload emitted on Polygon.
    /// @param attestation Chainlink attestation verifying the payload integrity.
    function forwardPolygonProof(bytes calldata message, bytes calldata attestation) external {
        bytes32 proofHash = keccak256(message);
        IMessageTransmitter(messageTransmitter).receiveMessage(message, attestation);
        emit PolygonProofForwarded(msg.sender, proofHash, attestation);
    }

    /// @notice Receives a Wormhole delivered proof produced on Solana and forwards it to the SoulKey gate.
    /// @param proof Encoded zk proof blob transferred by the Wormhole relayer.
    function receiveSolanaProof(bytes calldata proof) external {
        if (msg.sender != wormholeRelayer) {
            revert WormholeRelayerOnly();
        }
        (bool success, ) = soulKeyGate.call(abi.encodeWithSignature("verifySolanaProof(bytes)", proof));
        if (!success) {
            revert SoulKeyVerificationFailed();
        }
        emit SolanaProofReceived(keccak256(proof));
    }
}
